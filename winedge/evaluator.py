"""
Evaluator Module

The Evaluator module provides a class for evaluating the hand strength of a texas hold'em poker
hand at every stage of the game (preflop, flop, turn, river). The evaluation is
done by inputing card data generated by the card.py module for given input cards
and then utlizing a lookup table to determine the hand strength out of
all possible poker hands based on the player hand and the cards on the board.


Dependencies:
--------------
- card.py
- lookup.py

Classes:
--------------
- Evaluator:
    The main class that evaluates hand strengths based on the number of cards on the board and
    the players cards.

Evaluator Functions:
--------------
- evaluate(cards, board):
    The main function. When called it uses the lookup.py module to get the handrank for the input
    cards from 1 to 7462 (all possible poker hands). Lower ranked hands beat higher ranked hands.
    Arg:
        - cards: List of 32 bit int generated by the card.py module detailing the number and suite of
        the players hand cards.
        - board: List of 32 bit int generated by the card.py module detailing the number and suite of
        the board cards.
    Return:
        - (int) rank from 1 to 7462 of the poker hand out of all possible poker hands.
        Lower rank indicates a stronger hand. (e.g. Royal Flush Rank = 1)

- get_rank_class(hand_rank):
    Returns the class of hand (str) given the hand rank returned from the evaluate function.
    (e.g. Strongest feature of hand is two pairs of 5's and 3's - Class = "Two Pair)
    Arg:
        - hand_rank(int): Hand rank generated by the evaluate function. Int within range [1,7462].
    Return:
        - Hand class (string) of the poker hand input (e.g. "Two Pair", "Royal Flush", etc.)

- class_to_string(class_int):
    Converts the integer class hand score into names.

- get_rank_percentage(hand_rank):
    Normalizes the hand rank score from integers ranging in [1, 7462] to floating numbers ranging from 0 to 1.

Exception:
--------------
- ValueError: Raised when an invalid hand rank is encountered.
"""

import itertools
from .card import Card
from .lookup import LookupTable

class Evaluator(object):
    """
    Evaluate hand strengths. The first edition would focus on assessing the River round.
    """

    def __init__(self):

        self.table = LookupTable()

        self.hand_size_map = {
            5: self._flop,
            6: self._turn,
            7: self._river
        }

    def evaluate(self, cards, board):
        """
        The function to be called for getting the strength of a given hand. 

        Given the cards on deck, the function maps the scenario to specific evaluations.
        """

        all_cards = cards + board

        return self.hand_size_map[len(all_cards)](all_cards)

    def _flop(self, cards):
        """
        Fundamental evaluation function. It provides a rank in the range [1, 7462].
        """

        # check flush
        if cards[0] & cards[1] & cards[2] & cards[3] & cards[4] & 0xF000:
            handOR = (cards[0] | cards[1] | cards[2] | cards[3] | cards[4]) >> 16
            prime = Card.prime_product_from_rankbits(handOR)
            return self.table.flush_lookup[prime]

        # other patterns
        else:
            prime = Card.prime_product_from_hand(cards)
            return self.table.unsuited_lookup[prime]

    def _turn(self, cards):
        """
        Iterate all possible combinations of 5 cards from a 
        total of 6 cards and apply the five-card evaluation 
        on each combination. Then determine the best rank.
        """

        # set initial rank to be the lowest(unsuited 7-5-4-3-2), which
        # numerically is essentially the largest: 7462
        max_rank = LookupTable.MAX_HIGH_CARD

        allcombos = itertools.combinations(cards, 5)

        for combo in allcombos:

            score = self._flop(combo)
            if score < max_rank:
                # since the strength of a given hand is higher when the rank is smaller,
                # we should always return the smallest possible score.
                max_rank = score

        return max_rank

    def _river(self, cards):
        """
        Iterate all possible combinations of 5 cards from a 
        total of 7 cards and apply the five-card evaluation 
        on each combination. Then determine the best rank.
        """

        # set initial rank to be the lowest(unsuited 7-5-4-3-2),
        # which numerically is essentially the largest: 7462
        max_rank = LookupTable.MAX_HIGH_CARD

        allcombos = itertools.combinations(cards, 5)

        for combo in allcombos:

            score = self._flop(combo)
            if score < max_rank:
                # since the strength of a given hand is higher when the rank is smaller, we
                # should always return the smallest possible score.
                max_rank = score

        return max_rank

    def get_rank_class(self, hand_rank):
        """
        Returns the class of hand given the hand hand_rank
        returned from evaluate. 
        """
        if hand_rank >= 0 and hand_rank <= LookupTable.MAX_STRAIGHT_FLUSH:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_STRAIGHT_FLUSH]
        elif hand_rank <= LookupTable.MAX_FOUR_OF_A_KIND:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_FOUR_OF_A_KIND]
        elif hand_rank <= LookupTable.MAX_FULL_HOUSE:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_FULL_HOUSE]
        elif hand_rank <= LookupTable.MAX_FLUSH:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_FLUSH]
        elif hand_rank <= LookupTable.MAX_STRAIGHT:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_STRAIGHT]
        elif hand_rank <= LookupTable.MAX_THREE_OF_A_KIND:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_THREE_OF_A_KIND]
        elif hand_rank <= LookupTable.MAX_TWO_PAIR:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_TWO_PAIR]
        elif hand_rank <= LookupTable.MAX_PAIR:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_PAIR]
        elif hand_rank <= LookupTable.MAX_HIGH_CARD:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_HIGH_CARD]
        else:
            raise ValueError("Inavlid hand rank, cannot return rank class")


    def class_to_string(self, class_int):
        """
        Converts the integer class hand score into names.
        """
        return LookupTable.RANK_CLASS_TO_STRING[class_int]

    def get_rank_percentage(self, hand_rank):
        """
        Normalize the hand rank score. From intergers ranging in [1, 7462]
        to floating numbers ranging from 0 to 1. The mapping is in such a 
        way that the given hand would have a value representing that 
        it is stronger than p of the total hand, with p being the percent 
        of hands weaker than the given hand.
        """
        return 1 - (float(hand_rank) / float(LookupTable.MAX_HIGH_CARD))
